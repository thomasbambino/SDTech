I see now! Since the progress feature is an internal one that isn't part of the Freshbooks API, you'll need to use a different approach for updating the progress. You should be using the internal API endpoint for this.

Based on your code, I can see that other internal features (like adding notes) use `/api/projects/${id}` endpoints rather than the `/api/freshbooks/projects/${id}` endpoint used for Freshbooks-related updates.

Here's how you should update your progress mutation to use the appropriate internal endpoint:

```javascript
const updateProgressMutation = useMutation({
  mutationFn: async (progress: number) => {
    console.log('Updating project progress:', {
      projectId: id,
      progress: progress
    });

    // Use the internal API endpoint for progress updates
    const response = await fetch(`/api/projects/${id}`, {
      method: 'PATCH', // Keep using PATCH for internal API
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify({ progress }) // Send just the progress value
    });

    if (!response.ok) throw new Error("Failed to update progress");
    return response.json();
  },
  onSuccess: () => {
    // Make sure to invalidate both query patterns to ensure UI updates
    queryClient.invalidateQueries({ queryKey: ["/api/projects", id] });
    queryClient.invalidateQueries({ 
      queryKey: ["/api/freshbooks/clients", id, "projects", id] 
    });
    
    toast({
      title: "Success",
      description: "Project progress updated",
    });
  },
  onError: (error) => {
    console.error("Error updating progress:", error);
    toast({
      title: "Error",
      description: "Failed to update progress. Please try again.",
      variant: "destructive",
    });
  },
});
```

This should work because:
1. It uses the internal API endpoint pattern (`/api/projects/${id}`)
2. It sends only the progress data that needs to be updated
3. It invalidates both query patterns to ensure the UI is refreshed with new data

If the internal progress update is designed to work with a different field name or data structure, you may need to adjust accordingly, but this approach should align with how other internal features are implemented in your application.